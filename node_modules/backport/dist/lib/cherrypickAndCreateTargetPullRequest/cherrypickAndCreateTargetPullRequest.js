"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cherrypickAndCreateTargetPullRequest = void 0;
const chalk_1 = __importDefault(require("chalk"));
const lodash_1 = require("lodash");
const getSourceBranchFromCommits_1 = require("../getSourceBranchFromCommits");
const git_1 = require("../git");
const addAssigneesToPullRequest_1 = require("../github/v3/addAssigneesToPullRequest");
const addLabelsToPullRequest_1 = require("../github/v3/addLabelsToPullRequest");
const addReviewersToPullRequest_1 = require("../github/v3/addReviewersToPullRequest");
const createPullRequest_1 = require("../github/v3/createPullRequest");
const validateTargetBranch_1 = require("../github/v4/validateTargetBranch");
const logger_1 = require("../logger");
const sequentially_1 = require("../sequentially");
const autoMergeNowOrLater_1 = require("./autoMergeNowOrLater");
const getBackportBranchName_1 = require("./getBackportBranchName");
const getMergeCommit_1 = require("./getMergeCommit");
const getTargetPRLabels_1 = require("./getTargetPRLabels");
const waitForCherrypick_1 = require("./waitForCherrypick");
async function cherrypickAndCreateTargetPullRequest({ options, commits, targetBranch, }) {
    const backportBranch = (0, getBackportBranchName_1.getBackportBranchName)(targetBranch, commits);
    const repoForkOwner = (0, git_1.getRepoForkOwner)(options);
    (0, logger_1.consoleLog)(`\n${chalk_1.default.bold(`Backporting to ${targetBranch}:`)}`);
    await (0, validateTargetBranch_1.validateTargetBranch)({ ...options, branchName: targetBranch });
    await (0, git_1.createBackportBranch)({
        options,
        sourceBranch: (0, getSourceBranchFromCommits_1.getSourceBranchFromCommits)(commits),
        targetBranch,
        backportBranch,
    });
    const commitsFlattened = (0, lodash_1.flatten)(await Promise.all(commits.map((c) => (0, getMergeCommit_1.getMergeCommits)(options, c))));
    await (0, sequentially_1.sequentially)(commitsFlattened, (commit) => (0, waitForCherrypick_1.waitForCherrypick)(options, commit, targetBranch));
    if (!options.dryRun) {
        await (0, git_1.pushBackportBranch)({ options, backportBranch });
        await (0, git_1.deleteBackportBranch)({ options, backportBranch });
    }
    const prPayload = {
        owner: options.repoOwner,
        repo: options.repoName,
        title: (0, createPullRequest_1.getTitle)({ options, commits, targetBranch }),
        body: (0, createPullRequest_1.getPullRequestBody)({ options, commits, targetBranch }),
        head: `${repoForkOwner}:${backportBranch}`,
        base: targetBranch, // eg. 7.x
    };
    const targetPullRequest = await (0, createPullRequest_1.createPullRequest)({ options, prPayload });
    // add assignees to target pull request
    const assignees = options.autoAssign
        ? [options.authenticatedUsername]
        : options.assignees;
    if (options.assignees.length > 0) {
        await (0, addAssigneesToPullRequest_1.addAssigneesToPullRequest)({
            ...options,
            pullNumber: targetPullRequest.number,
            assignees,
        });
    }
    // add reviewers to target pull request
    if (options.reviewers.length > 0) {
        await (0, addReviewersToPullRequest_1.addReviewersToPullRequest)(options, targetPullRequest.number, options.reviewers);
    }
    // add labels to target pull request
    if (options.targetPRLabels.length > 0) {
        const labels = (0, getTargetPRLabels_1.getTargetPRLabels)({
            interactive: options.interactive,
            targetPRLabels: options.targetPRLabels,
            commits,
            targetBranch,
        });
        await (0, addLabelsToPullRequest_1.addLabelsToPullRequest)({
            ...options,
            pullNumber: targetPullRequest.number,
            labels,
        });
    }
    // make PR auto mergable
    if (options.autoMerge) {
        await (0, autoMergeNowOrLater_1.autoMergeNowOrLater)(options, targetPullRequest.number);
    }
    // add labels to source pull requests
    if (options.sourcePRLabels.length > 0) {
        const promises = commits.map((commit) => {
            if (commit.sourcePullRequest) {
                return (0, addLabelsToPullRequest_1.addLabelsToPullRequest)({
                    ...options,
                    pullNumber: commit.sourcePullRequest.number,
                    labels: options.sourcePRLabels,
                });
            }
        });
        await Promise.all(promises);
    }
    (0, logger_1.consoleLog)(`View pull request: ${targetPullRequest.url}`);
    return targetPullRequest;
}
exports.cherrypickAndCreateTargetPullRequest = cherrypickAndCreateTargetPullRequest;
//# sourceMappingURL=cherrypickAndCreateTargetPullRequest.js.map