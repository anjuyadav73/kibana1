"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceCommitWithTargetPullRequestFragment = exports.parseSourceCommit = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const lodash_1 = require("lodash");
const remoteConfig_1 = require("../remoteConfig");
const getPullRequestStates_1 = require("./getPullRequestStates");
function getSuggestedTargetBranches(sourceCommit, targetPullRequestStates, branchLabelMapping) {
    const missingPrs = (0, getPullRequestStates_1.getPullRequestStates)({
        sourceCommit,
        branchLabelMapping,
    }).filter((pr) => pr.state === 'NOT_CREATED' || pr.state === 'CLOSED');
    const mergedPrs = targetPullRequestStates.filter((pr) => pr.state === 'MERGED');
    return (0, lodash_1.differenceBy)(missingPrs, mergedPrs, (pr) => pr.label).map((pr) => pr.branch);
}
function parseSourceCommit({ sourceCommit, options, }) {
    const sourcePullRequest = (0, getPullRequestStates_1.getSourcePullRequest)(sourceCommit);
    const sourceCommitBranchLabelMapping = getSourceCommitBranchLabelMapping(sourceCommit);
    const currentBranchLabelMapping = options.branchLabelMapping;
    const targetPullRequestStates = (0, getPullRequestStates_1.getPullRequestStates)({
        sourceCommit,
        branchLabelMapping: sourceCommitBranchLabelMapping ?? currentBranchLabelMapping,
    });
    const suggestedTargetBranches = getSuggestedTargetBranches(sourceCommit, targetPullRequestStates, currentBranchLabelMapping);
    return {
        author: sourceCommit.author,
        sourceCommit: {
            committedDate: sourceCommit.committedDate,
            message: sourceCommit.message,
            sha: sourceCommit.sha,
            branchLabelMapping: sourceCommitBranchLabelMapping,
        },
        sourcePullRequest: sourcePullRequest
            ? {
                labels: sourcePullRequest.labels.nodes.map((label) => label.name),
                number: sourcePullRequest.number,
                url: sourcePullRequest.url,
                mergeCommit: {
                    message: sourcePullRequest.mergeCommit.message,
                    sha: sourcePullRequest.mergeCommit.sha,
                },
            }
            : undefined,
        sourceBranch: sourcePullRequest?.baseRefName ?? options.sourceBranch,
        suggestedTargetBranches,
        targetPullRequestStates: targetPullRequestStates,
    };
}
exports.parseSourceCommit = parseSourceCommit;
exports.SourceCommitWithTargetPullRequestFragment = (0, graphql_tag_1.default) `
  fragment SourceCommitWithTargetPullRequestFragment on Commit {
    # Source Commit
    repository {
      name
      owner {
        login
      }
    }
    sha: oid
    message
    committedDate

    author {
      name
      email
    }

    # Source pull request: PR where source commit was merged in
    associatedPullRequests(first: 1) {
      edges {
        node {
          url
          number
          labels(first: 50) {
            nodes {
              name
            }
          }
          baseRefName

          # source merge commit (the commit that actually went into the source branch)
          mergeCommit {
            ...RemoteConfigHistoryFragment
            sha: oid
            message
          }

          # (possible) backport pull requests referenced in the source pull request
          timelineItems(last: 20, itemTypes: CROSS_REFERENCED_EVENT) {
            edges {
              node {
                ... on CrossReferencedEvent {
                  targetPullRequest: source {
                    __typename

                    # Target PRs (backport PRs)
                    ... on PullRequest {
                      # target merge commit: the backport commit that was merged into the target branch
                      targetMergeCommit: mergeCommit {
                        sha: oid
                        message
                      }
                      repository {
                        name
                        owner {
                          login
                        }
                      }
                      url
                      title
                      state
                      baseRefName
                      number
                      commits(first: 20) {
                        edges {
                          node {
                            targetCommit: commit {
                              message
                              sha: oid
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  ${remoteConfig_1.RemoteConfigHistoryFragment}
`;
function getSourceCommitBranchLabelMapping(sourceCommit) {
    const sourcePullRequest = (0, getPullRequestStates_1.getSourcePullRequest)(sourceCommit);
    const remoteConfig = sourcePullRequest?.mergeCommit.remoteConfigHistory.edges?.[0]?.remoteConfig;
    if (remoteConfig) {
        return (0, remoteConfig_1.parseRemoteConfig)(remoteConfig)?.branchLabelMapping;
    }
}
//# sourceMappingURL=parseSourceCommit.js.map