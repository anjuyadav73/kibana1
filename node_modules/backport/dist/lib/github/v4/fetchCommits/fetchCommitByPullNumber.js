"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCommitsByPullNumber = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const BackportError_1 = require("../../../BackportError");
const remoteConfig_1 = require("../../../remoteConfig");
const apiRequestV4_1 = require("../apiRequestV4");
const fetchCommitBySha_1 = require("./fetchCommitBySha");
const fetchCommitsForRebaseAndMergeStrategy_1 = require("./fetchCommitsForRebaseAndMergeStrategy");
async function fetchCommitsByPullNumber(options) {
    const { accessToken, githubApiBaseUrlV4 = 'https://api.github.com/graphql', pullNumber, repoName, repoOwner, } = options;
    const query = (0, graphql_tag_1.default) `
    query CommitByPullNumber(
      $repoOwner: String!
      $repoName: String!
      $pullNumber: Int!
    ) {
      repository(owner: $repoOwner, name: $repoName) {
        pullRequest(number: $pullNumber) {
          # used to determine if "Rebase and Merge" strategy was used
          commits(last: 1) {
            totalCount
            edges {
              node {
                commit {
                  message
                }
              }
            }
          }

          mergeCommit {
            oid

            # used to determine if "Rebase and Merge" strategy was used
            committedDate
            history(first: 2) {
              edges {
                node {
                  message
                  committedDate
                }
              }
            }
          }
        }
      }
    }
  `;
    let res;
    try {
        res = await (0, apiRequestV4_1.apiRequestV4)({
            githubApiBaseUrlV4,
            accessToken,
            query,
            variables: {
                repoOwner,
                repoName,
                pullNumber,
            },
        });
    }
    catch (e) {
        res = (0, remoteConfig_1.swallowMissingConfigFileException)(e);
    }
    const pullRequestNode = res.repository.pullRequest;
    if (!pullRequestNode) {
        throw new BackportError_1.BackportError(`The PR #${pullNumber} does not exist`);
    }
    const { mergeCommit } = pullRequestNode;
    if (mergeCommit === null) {
        throw new BackportError_1.BackportError(`The PR #${pullNumber} is not merged`);
    }
    const lastCommitInPullRequest = pullRequestNode.commits.edges[0].node.commit;
    const firstCommitInBaseBranch = mergeCommit.history.edges[0].node;
    const isRebaseAndMergeStrategy = pullRequestNode.commits.totalCount > 0 &&
        mergeCommit.history.edges.every((c) => c.node.committedDate === mergeCommit.committedDate) &&
        lastCommitInPullRequest.message === firstCommitInBaseBranch.message;
    if (isRebaseAndMergeStrategy) {
        const commits = await (0, fetchCommitsForRebaseAndMergeStrategy_1.fetchCommitsForRebaseAndMergeStrategy)(options, pullRequestNode.commits.totalCount);
        if (commits) {
            return commits;
        }
    }
    const commit = await (0, fetchCommitBySha_1.fetchCommitBySha)({ ...options, sha: mergeCommit.oid });
    return [commit];
}
exports.fetchCommitsByPullNumber = fetchCommitsByPullNumber;
//# sourceMappingURL=fetchCommitByPullNumber.js.map