"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCommitsForRebaseAndMergeStrategy = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const apiRequestV4_1 = require("../apiRequestV4");
const fetchCommitBySha_1 = require("./fetchCommitBySha");
async function fetchCommitsForRebaseAndMergeStrategy(options, commitsTotalCount) {
    const { accessToken, githubApiBaseUrlV4 = 'https://api.github.com/graphql', pullNumber, repoName, repoOwner, } = options;
    const query = (0, graphql_tag_1.default) `
    query CommitsForRebaseAndMergeStrategy(
      $repoOwner: String!
      $repoName: String!
      $pullNumber: Int!
      $commitsTotalCount: Int!
    ) {
      repository(owner: $repoOwner, name: $repoName) {
        pullRequest(number: $pullNumber) {
          number
          commits(first: $commitsTotalCount) {
            totalCount
            edges {
              node {
                commit {
                  message
                }
              }
            }
          }

          mergeCommit {
            committedDate
            history(first: $commitsTotalCount) {
              edges {
                node {
                  oid
                  message
                  committedDate
                  associatedPullRequests(first: 1) {
                    edges {
                      node {
                        number
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
    const res = await (0, apiRequestV4_1.apiRequestV4)({
        githubApiBaseUrlV4,
        accessToken,
        query,
        variables: {
            repoOwner,
            repoName,
            pullNumber,
            commitsTotalCount,
        },
    });
    const pullRequestNode = res.repository.pullRequest;
    if (!pullRequestNode?.mergeCommit) {
        throw new Error('Pull request is not merged');
    }
    if (pullRequestNode.commits.totalCount !== commitsTotalCount) {
        throw new Error(`Specified number of commits is ${commitsTotalCount} whereas the actual number is ${pullRequestNode.commits.totalCount}`);
    }
    const commitsInPullRequest = pullRequestNode.commits.edges;
    const commitsInBaseBranch = pullRequestNode.mergeCommit.history.edges.reverse();
    const didUseRebaseAndMergeStrategy = commitsInBaseBranch.every((c, i) => {
        const hasSameCommittedDate = c.node.committedDate === pullRequestNode.mergeCommit?.committedDate;
        const hasSameCommitMessages = c.node.message === commitsInPullRequest[i].node.commit.message;
        const hasSamePullNumber = c.node.associatedPullRequests.edges[0].node.number ===
            pullRequestNode.number;
        return hasSameCommittedDate && hasSameCommitMessages && hasSamePullNumber;
    });
    if (didUseRebaseAndMergeStrategy) {
        const commits = await Promise.all(commitsInBaseBranch.map((c) => (0, fetchCommitBySha_1.fetchCommitBySha)({ ...options, sha: c.node.oid })));
        return commits;
    }
}
exports.fetchCommitsForRebaseAndMergeStrategy = fetchCommitsForRebaseAndMergeStrategy;
//# sourceMappingURL=fetchCommitsForRebaseAndMergeStrategy.js.map