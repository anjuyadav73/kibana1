"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTitle = exports.getPullRequestBody = exports.createPullRequest = void 0;
const rest_1 = require("@octokit/rest");
const elastic_apm_node_1 = __importDefault(require("elastic-apm-node"));
const ora_1 = require("../../../lib/ora");
const packageVersion_1 = require("../../../utils/packageVersion");
const BackportError_1 = require("../../BackportError");
const getSourceBranchFromCommits_1 = require("../../getSourceBranchFromCommits");
const logger_1 = require("../../logger");
const commitFormatters_1 = require("../commitFormatters");
const fetchExistingPullRequest_1 = require("../v4/fetchExistingPullRequest");
const getGithubV3ErrorMessage_1 = require("./getGithubV3ErrorMessage");
async function createPullRequest({ options, prPayload, }) {
    logger_1.logger.info(`Creating PR with title: "${prPayload.title}". ${prPayload.head} -> ${prPayload.base}`);
    const { accessToken, githubApiBaseUrlV3 } = options;
    const spinner = (0, ora_1.ora)(options.interactive, `Creating pull request`).start();
    if (options.dryRun) {
        spinner.succeed();
        return { didUpdate: false, number: 1337, url: 'this-is-a-dry-run' };
    }
    const span = elastic_apm_node_1.default.startSpan('REST: Create pull request');
    try {
        const octokit = new rest_1.Octokit({
            auth: accessToken,
            baseUrl: githubApiBaseUrlV3,
            log: logger_1.logger,
        });
        const res = await octokit.pulls.create(prPayload);
        spinner.succeed();
        return {
            url: res.data.html_url,
            number: res.data.number,
            didUpdate: false,
        };
    }
    catch (e) {
        // retrieve url for existing
        try {
            const existingPR = await (0, fetchExistingPullRequest_1.fetchExistingPullRequest)({
                options,
                prPayload,
            });
            if (existingPR) {
                spinner.succeed('Updating existing pull request');
                return {
                    url: existingPR.url,
                    number: existingPR.number,
                    didUpdate: true,
                };
            }
        }
        catch (e) {
            logger_1.logger.error('Could not retrieve existing pull request', e);
            // swallow error
        }
        finally {
            span?.end();
        }
        spinner.fail();
        throw new BackportError_1.BackportError(
        //@ts-expect-error
        `Could not create pull request: ${(0, getGithubV3ErrorMessage_1.getGithubV3ErrorMessage)(e)}`);
    }
}
exports.createPullRequest = createPullRequest;
function getPullRequestBody({ options, commits, targetBranch, }) {
    const commitMessages = commits
        .map((c) => {
        const message = c.sourcePullRequest
            ? `[${(0, commitFormatters_1.getFirstLine)(c.sourceCommit.message)}](${c.sourcePullRequest.url})`
            : `${(0, commitFormatters_1.getFirstLine)(c.sourceCommit.message)} (${(0, commitFormatters_1.getShortSha)(c.sourceCommit.sha)})`;
        return ` - ${message}`;
    })
        .join('\n');
    const sourceBranch = (0, getSourceBranchFromCommits_1.getSourceBranchFromCommits)(commits);
    const defaultPrDescription = `# Backport

This will backport the following commits from \`${sourceBranch}\` to \`${targetBranch}\`:
${commitMessages}

<!--- Backport version: ${packageVersion_1.PACKAGE_VERSION} -->

### Questions ?
Please refer to the [Backport tool documentation](https://github.com/sqren/backport)`;
    return (options.prDescription ?? defaultPrDescription)
        .replaceAll('{targetBranch}', targetBranch)
        .replaceAll('{commitMessages}', commitMessages)
        .replaceAll('{defaultPrDescription}', defaultPrDescription)
        .replaceAll('{commits}', JSON.stringify(commits));
}
exports.getPullRequestBody = getPullRequestBody;
function getTitle({ options, commits, targetBranch, }) {
    const commitMessages = commits
        .map((c) => (0, commitFormatters_1.getFirstLine)(c.sourceCommit.message))
        .join(' | ');
    const defaultPrTitle = '[{targetBranch}] {commitMessages}';
    return (options.prTitle ?? defaultPrTitle)
        .replaceAll('{targetBranch}', targetBranch)
        .replaceAll('{commitMessages}', commitMessages)
        .slice(0, 240);
}
exports.getTitle = getTitle;
//# sourceMappingURL=createPullRequest.js.map