"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSequentially = void 0;
const elastic_apm_node_1 = __importDefault(require("elastic-apm-node"));
const BackportError_1 = require("./lib/BackportError");
const cherrypickAndCreateTargetPullRequest_1 = require("./lib/cherrypickAndCreateTargetPullRequest/cherrypickAndCreateTargetPullRequest");
const env_1 = require("./lib/env");
const logger_1 = require("./lib/logger");
const sequentially_1 = require("./lib/sequentially");
async function runSequentially({ options, commits, targetBranches, }) {
    logger_1.logger.verbose('Backport options', options);
    const results = [];
    await (0, sequentially_1.sequentially)(targetBranches, async (targetBranch) => {
        logger_1.logger.info(`Backporting ${JSON.stringify(commits)} to ${targetBranch}`);
        const span = elastic_apm_node_1.default.startSpan('Cherrypick commits to target branch');
        try {
            const { number, url, didUpdate } = await (0, cherrypickAndCreateTargetPullRequest_1.cherrypickAndCreateTargetPullRequest)({
                options,
                commits,
                targetBranch,
            });
            results.push({
                targetBranch,
                status: 'success',
                didUpdate,
                pullRequestUrl: url,
                pullRequestNumber: number,
            });
            span?.setOutcome('success');
            span?.end();
        }
        catch (e) {
            span?.setOutcome('failure');
            span?.setLabel('error_message', e.message);
            span?.end();
            elastic_apm_node_1.default.captureError(e);
            const isHandledError = e instanceof BackportError_1.BackportError;
            if (isHandledError) {
                results.push({
                    targetBranch,
                    status: 'handled-error',
                    error: e,
                });
            }
            else if (e instanceof Error) {
                results.push({
                    targetBranch,
                    status: 'unhandled-error',
                    error: e,
                });
            }
            else {
                throw e;
            }
            logger_1.logger.error('runSequentially failed', e);
            if (isHandledError) {
                // don't output anything for `code: invalid-branch-exception`.
                // Outputting is already handled
                if (e.errorContext.code !== 'invalid-branch-exception') {
                    (0, logger_1.consoleLog)(e.message);
                }
                return;
            }
            (0, logger_1.consoleLog)(`An unhandled error occurred while backporting commit. Please see the logs for details: ${(0, env_1.getLogfilePath)({ logFilePath: options.logFilePath, logLevel: 'info' })}`);
        }
    });
    // return the results for consumers to programatically read
    return results;
}
exports.runSequentially = runSequentially;
//# sourceMappingURL=runSequentially.js.map