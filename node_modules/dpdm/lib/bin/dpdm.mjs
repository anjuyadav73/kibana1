#!/usr/bin/env node
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-07-17 18:45:32
 */
import { __awaiter, __generator, __read, __spread, __values } from "tslib";
import chalk from 'chalk';
import fs from 'fs-extra';
import ora from 'ora';
import path from 'path';
import yargs from 'yargs';
import { parseDependencyTree } from '../parser';
import { defaultOptions, glob, parseCircular, parseWarnings, prettyCircular, prettyTree, prettyWarning, simpleResolver, } from '../utils';
var argv = yargs
    .strict()
    .usage('$0 [options] files...')
    .option('context', {
    type: 'string',
    desc: 'the context directory to shorten path, default is current directory',
})
    .option('extensions', {
    alias: 'ext',
    type: 'string',
    desc: 'comma separated extensions to resolve',
    default: defaultOptions.extensions.filter(Boolean).join(','),
})
    .option('js', {
    type: 'string',
    desc: 'comma separated extensions indicate the file is js like',
    default: defaultOptions.js.join(','),
})
    .option('include', {
    type: 'string',
    desc: 'included filenames regexp in string, default includes all files',
    default: defaultOptions.include.source,
})
    .option('exclude', {
    type: 'string',
    desc: 'excluded filenames regexp in string, set as empty string to include all files',
    default: defaultOptions.exclude.source,
})
    .option('output', {
    alias: 'o',
    type: 'string',
    desc: 'output json to file',
})
    .option('tree', {
    type: 'boolean',
    desc: 'print tree to stdout',
    default: true,
})
    .option('circular', {
    type: 'boolean',
    desc: 'print circular to stdout',
    default: true,
})
    .option('warning', {
    type: 'boolean',
    desc: 'print warning to stdout',
    default: true,
})
    .option('tsconfig', {
    type: 'string',
    desc: 'the tsconfig path, which is used for resolve path alias, default is tsconfig.json if it exists in context directory',
})
    .option('transform', {
    type: 'boolean',
    desc: 'transform typescript modules to javascript before analyze, it allows you to omit types dependency in typescript',
    default: defaultOptions.transform,
    alias: 'T',
})
    .option('exit-code', {
    type: 'string',
    desc: 'exit with specified code, the value format is CASE:CODE, `circular` is the only supported CASE, ' +
        'CODE should be a integer between 0 and 128. ' +
        'For example: `dpdm --exit-code circular:1` the program will exit with code 1 if circular dependency found.',
})
    .alias('h', 'help')
    .wrap(Math.min(yargs.terminalWidth(), 100)).argv;
if (argv._.length === 0) {
    yargs.showHelp();
    console.log('\nMissing entry file');
    process.exit(1);
}
var exitCases = new Set(['circular']);
var exitCodes = [];
if (argv['exit-code']) {
    argv['exit-code'].split(',').forEach(function (c) {
        var _a = __read(c.split(':'), 2), label = _a[0], code = _a[1];
        if (!code || !isFinite(+code)) {
            throw new TypeError("exit code should be a number");
        }
        if (!exitCases.has(label)) {
            throw new TypeError("unsupported exit case \"" + label + "\"");
        }
        exitCodes.push([label, +code]);
    });
}
var o = ora('Loading dependencies...').start();
var total = 0;
var ended = 0;
var current = '';
var context = argv.context || process.cwd();
function onProgress(event, target) {
    switch (event) {
        case 'start':
            total += 1;
            current = path.relative(context, target);
            break;
        case 'end':
            ended += 1;
            break;
    }
    o.text = "[" + ended + "/" + total + "] Analyzing " + current + "...";
    o.render();
}
var options = {
    context: context,
    extensions: argv.extensions.split(','),
    js: argv.js.split(','),
    include: new RegExp(argv.include || '.*'),
    exclude: new RegExp(argv.exclude || '$.'),
    tsconfig: argv.tsconfig,
    transform: argv.transform,
    onProgress: onProgress,
};
parseDependencyTree(argv._, options)
    .then(function (tree) { return __awaiter(void 0, void 0, void 0, function () {
    var entriesDeep, entries, circulars, exitCodes_1, exitCodes_1_1, _a, label, code;
    var _b, e_1, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                o.succeed("[" + ended + "/" + total + "] Analyze done!");
                return [4 /*yield*/, Promise.all(argv._.map(function (g) { return glob(g); }))];
            case 1:
                entriesDeep = _d.sent();
                return [4 /*yield*/, Promise.all((_b = Array()).concat.apply(_b, __spread(entriesDeep)).map(function (name) {
                        return simpleResolver(options.context, path.join(options.context, name), options.extensions).then(function (id) { return (id ? path.relative(options.context, id) : name); });
                    }))];
            case 2:
                entries = _d.sent();
                circulars = parseCircular(tree);
                if (!argv.output) return [3 /*break*/, 4];
                return [4 /*yield*/, fs.outputJSON(argv.output, { entries: entries, tree: tree, circulars: circulars }, { spaces: 2 })];
            case 3:
                _d.sent();
                _d.label = 4;
            case 4:
                if (argv.tree) {
                    console.log(chalk.bold('• Dependencies Tree'));
                    console.log(prettyTree(tree, entries));
                    console.log('');
                }
                if (argv.circular) {
                    console.log(chalk.bold.red('• Circular Dependencies'));
                    if (circulars.length === 0) {
                        console.log(chalk.bold.green('  ✅ Congratulations, no circular dependency were found in your project.'));
                    }
                    else {
                        console.log(prettyCircular(circulars));
                    }
                    console.log('');
                }
                if (argv.warning) {
                    console.log(chalk.bold.yellow('• Warnings'));
                    console.log(prettyWarning(parseWarnings(tree)));
                    console.log('');
                }
                try {
                    for (exitCodes_1 = __values(exitCodes), exitCodes_1_1 = exitCodes_1.next(); !exitCodes_1_1.done; exitCodes_1_1 = exitCodes_1.next()) {
                        _a = __read(exitCodes_1_1.value, 2), label = _a[0], code = _a[1];
                        switch (label) {
                            case 'circular':
                                if (circulars.length > 0) {
                                    process.exit(code);
                                }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (exitCodes_1_1 && !exitCodes_1_1.done && (_c = exitCodes_1.return)) _c.call(exitCodes_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return [2 /*return*/];
        }
    });
}); })
    .catch(function (e) {
    o.fail();
    console.error(e.stack || e);
    process.exit(1);
});
//# sourceMappingURL=dpdm.js.map