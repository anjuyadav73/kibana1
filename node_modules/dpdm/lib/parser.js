"use strict";
/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-07-17 18:45:32
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
var path_1 = tslib_1.__importDefault(require("path"));
var typescript_1 = tslib_1.__importDefault(require("typescript"));
var consts_1 = require("./consts");
var utils_1 = require("./utils");
var typescriptTransformOptions = {
    target: typescript_1.default.ScriptTarget.ESNext,
    module: typescript_1.default.ModuleKind.ESNext,
    jsx: typescript_1.default.JsxEmit.Preserve,
    isolatedModules: true,
};
function parseTreeRecursive(context, request, options, output, resolve) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        function nodeVisitor(node) {
            var newRequest;
            var kind;
            if (typescript_1.default.isImportDeclaration(node)) {
                newRequest = node.moduleSpecifier.text;
                kind = consts_1.DependencyKind.StaticImport;
            }
            else if (typescript_1.default.isCallExpression(node) &&
                node.expression.kind === typescript_1.default.SyntaxKind.ImportKeyword &&
                node.arguments.length === 1 &&
                typescript_1.default.isStringLiteral(node.arguments[0])) {
                newRequest = node.arguments[0].text;
                kind = consts_1.DependencyKind.DynamicImport;
            }
            else if (typescript_1.default.isCallExpression(node) &&
                typescript_1.default.isIdentifier(node.expression) &&
                node.expression.escapedText === 'require' &&
                node.arguments.length === 1 &&
                typescript_1.default.isStringLiteral(node.arguments[0])) {
                newRequest = node.arguments[0].text;
                kind = consts_1.DependencyKind.CommonJS;
            }
            else if (typescript_1.default.isExportDeclaration(node) &&
                node.moduleSpecifier &&
                typescript_1.default.isStringLiteral(node.moduleSpecifier)) {
                newRequest = node.moduleSpecifier.text;
                kind = consts_1.DependencyKind.StaticExport;
            }
            else {
                typescript_1.default.forEachChild(node, nodeVisitor);
                return;
            }
            dependencies.push({
                issuer: id,
                request: newRequest,
                kind: kind,
                id: null,
            });
            jobs.push(parseTreeRecursive(newContext, newRequest, options, output, resolve));
        }
        var id, dependencies, jobs, newContext, code, ext, source;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, resolve(context, request, options.extensions)];
                case 1:
                    id = _a.sent();
                    if (!id || output[id]) {
                        return [2 /*return*/, id];
                    }
                    if (!options.include.test(id) || options.exclude.test(id)) {
                        output[id] = null;
                        return [2 /*return*/, id];
                    }
                    if (options.js.indexOf(path_1.default.extname(id)) === -1) {
                        output[id] = [];
                        return [2 /*return*/, id];
                    }
                    options.onProgress('start', id);
                    dependencies = (output[id] = []);
                    jobs = [];
                    newContext = path_1.default.dirname(id);
                    return [4 /*yield*/, fs_extra_1.default.readFile(id, 'utf8')];
                case 2:
                    code = _a.sent();
                    ext = path_1.default.extname(id);
                    if (options.transform &&
                        (ext === typescript_1.default.Extension.Ts || ext === typescript_1.default.Extension.Tsx)) {
                        typescript_1.default.transpileModule(code, {
                            compilerOptions: typescriptTransformOptions,
                            transformers: {
                                after: [function () { return function (node) { return (source = node); }; }],
                            },
                        });
                    }
                    else {
                        source = typescript_1.default.createSourceFile(id, code, typescript_1.default.ScriptTarget.Latest, true, typescript_1.default.ScriptKind.TSX);
                    }
                    typescript_1.default.forEachChild(source, nodeVisitor);
                    options.onProgress('end', id);
                    return [2 /*return*/, Promise.all(jobs).then(function (deps) {
                            deps.forEach(function (id, index) { return (dependencies[index].id = id); });
                            return id;
                        })];
            }
        });
    });
}
/**
 * @param entries - the entry glob list
 * @param options
 */
function parseDependencyTree(entries, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var currentDirectory, output, fullOptions, resolve, compilerOptions_1, host_1;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!Array.isArray(entries)) {
                        entries = [entries];
                    }
                    currentDirectory = process.cwd();
                    output = {};
                    fullOptions = utils_1.normalizeOptions(options);
                    resolve = utils_1.simpleResolver;
                    if (options.tsconfig) {
                        compilerOptions_1 = typescript_1.default.parseJsonConfigFileContent(typescript_1.default.readConfigFile(options.tsconfig, typescript_1.default.sys.readFile).config, typescript_1.default.sys, path_1.default.dirname(options.tsconfig)).options;
                        host_1 = typescript_1.default.createCompilerHost(compilerOptions_1);
                        resolve = function (context, request, extensions) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var module, filename;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        module = typescript_1.default.resolveModuleName(request, path_1.default.join(context, 'index.ts'), compilerOptions_1, host_1).resolvedModule;
                                        if (!(module && module.extension !== typescript_1.default.Extension.Dts)) return [3 /*break*/, 1];
                                        return [2 /*return*/, module.resolvedFileName];
                                    case 1: return [4 /*yield*/, utils_1.simpleResolver(context, request, extensions)];
                                    case 2:
                                        filename = _a.sent();
                                        if (filename === null && module) {
                                            return [2 /*return*/, utils_1.simpleResolver(context, module.resolvedFileName.slice(0, -typescript_1.default.Extension.Dts.length), extensions)];
                                        }
                                        return [2 /*return*/, filename];
                                }
                            });
                        }); };
                    }
                    return [4 /*yield*/, Promise.all(entries.map(function (entry) {
                            return utils_1.glob(entry).then(function (matches) {
                                return Promise.all(matches.map(function (filename) {
                                    return parseTreeRecursive(currentDirectory, path_1.default.join(currentDirectory, filename), fullOptions, output, resolve);
                                }));
                            });
                        }))];
                case 1:
                    _a.sent();
                    if (fullOptions.context) {
                        return [2 /*return*/, utils_1.shortenTree(fullOptions.context, output)];
                    }
                    return [2 /*return*/, output];
            }
        });
    });
}
exports.parseDependencyTree = parseDependencyTree;
//# sourceMappingURL=parser.js.map