/*!
 * Copyright 2019 acrazing <joking.young@gmail.com>. All rights reserved.
 * @since 2019-07-17 18:45:32
 */
import { __awaiter, __generator } from "tslib";
import fs from 'fs-extra';
import path from 'path';
import ts from 'typescript';
import { DependencyKind } from './consts';
import { glob, normalizeOptions, shortenTree, simpleResolver, } from './utils';
var typescriptTransformOptions = {
    target: ts.ScriptTarget.ESNext,
    module: ts.ModuleKind.ESNext,
    jsx: ts.JsxEmit.Preserve,
    isolatedModules: true,
};
function parseTreeRecursive(context, request, options, output, resolve) {
    return __awaiter(this, void 0, void 0, function () {
        function nodeVisitor(node) {
            var newRequest;
            var kind;
            if (ts.isImportDeclaration(node)) {
                newRequest = node.moduleSpecifier.text;
                kind = DependencyKind.StaticImport;
            }
            else if (ts.isCallExpression(node) &&
                node.expression.kind === ts.SyntaxKind.ImportKeyword &&
                node.arguments.length === 1 &&
                ts.isStringLiteral(node.arguments[0])) {
                newRequest = node.arguments[0].text;
                kind = DependencyKind.DynamicImport;
            }
            else if (ts.isCallExpression(node) &&
                ts.isIdentifier(node.expression) &&
                node.expression.escapedText === 'require' &&
                node.arguments.length === 1 &&
                ts.isStringLiteral(node.arguments[0])) {
                newRequest = node.arguments[0].text;
                kind = DependencyKind.CommonJS;
            }
            else if (ts.isExportDeclaration(node) &&
                node.moduleSpecifier &&
                ts.isStringLiteral(node.moduleSpecifier)) {
                newRequest = node.moduleSpecifier.text;
                kind = DependencyKind.StaticExport;
            }
            else {
                ts.forEachChild(node, nodeVisitor);
                return;
            }
            dependencies.push({
                issuer: id,
                request: newRequest,
                kind: kind,
                id: null,
            });
            jobs.push(parseTreeRecursive(newContext, newRequest, options, output, resolve));
        }
        var id, dependencies, jobs, newContext, code, ext, source;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, resolve(context, request, options.extensions)];
                case 1:
                    id = _a.sent();
                    if (!id || output[id]) {
                        return [2 /*return*/, id];
                    }
                    if (!options.include.test(id) || options.exclude.test(id)) {
                        output[id] = null;
                        return [2 /*return*/, id];
                    }
                    if (options.js.indexOf(path.extname(id)) === -1) {
                        output[id] = [];
                        return [2 /*return*/, id];
                    }
                    options.onProgress('start', id);
                    dependencies = (output[id] = []);
                    jobs = [];
                    newContext = path.dirname(id);
                    return [4 /*yield*/, fs.readFile(id, 'utf8')];
                case 2:
                    code = _a.sent();
                    ext = path.extname(id);
                    if (options.transform &&
                        (ext === ts.Extension.Ts || ext === ts.Extension.Tsx)) {
                        ts.transpileModule(code, {
                            compilerOptions: typescriptTransformOptions,
                            transformers: {
                                after: [function () { return function (node) { return (source = node); }; }],
                            },
                        });
                    }
                    else {
                        source = ts.createSourceFile(id, code, ts.ScriptTarget.Latest, true, ts.ScriptKind.TSX);
                    }
                    ts.forEachChild(source, nodeVisitor);
                    options.onProgress('end', id);
                    return [2 /*return*/, Promise.all(jobs).then(function (deps) {
                            deps.forEach(function (id, index) { return (dependencies[index].id = id); });
                            return id;
                        })];
            }
        });
    });
}
/**
 * @param entries - the entry glob list
 * @param options
 */
export function parseDependencyTree(entries, options) {
    return __awaiter(this, void 0, void 0, function () {
        var currentDirectory, output, fullOptions, resolve, compilerOptions_1, host_1;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!Array.isArray(entries)) {
                        entries = [entries];
                    }
                    currentDirectory = process.cwd();
                    output = {};
                    fullOptions = normalizeOptions(options);
                    resolve = simpleResolver;
                    if (options.tsconfig) {
                        compilerOptions_1 = ts.parseJsonConfigFileContent(ts.readConfigFile(options.tsconfig, ts.sys.readFile).config, ts.sys, path.dirname(options.tsconfig)).options;
                        host_1 = ts.createCompilerHost(compilerOptions_1);
                        resolve = function (context, request, extensions) { return __awaiter(_this, void 0, void 0, function () {
                            var module, filename;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        module = ts.resolveModuleName(request, path.join(context, 'index.ts'), compilerOptions_1, host_1).resolvedModule;
                                        if (!(module && module.extension !== ts.Extension.Dts)) return [3 /*break*/, 1];
                                        return [2 /*return*/, module.resolvedFileName];
                                    case 1: return [4 /*yield*/, simpleResolver(context, request, extensions)];
                                    case 2:
                                        filename = _a.sent();
                                        if (filename === null && module) {
                                            return [2 /*return*/, simpleResolver(context, module.resolvedFileName.slice(0, -ts.Extension.Dts.length), extensions)];
                                        }
                                        return [2 /*return*/, filename];
                                }
                            });
                        }); };
                    }
                    return [4 /*yield*/, Promise.all(entries.map(function (entry) {
                            return glob(entry).then(function (matches) {
                                return Promise.all(matches.map(function (filename) {
                                    return parseTreeRecursive(currentDirectory, path.join(currentDirectory, filename), fullOptions, output, resolve);
                                }));
                            });
                        }))];
                case 1:
                    _a.sent();
                    if (fullOptions.context) {
                        return [2 /*return*/, shortenTree(fullOptions.context, output)];
                    }
                    return [2 /*return*/, output];
            }
        });
    });
}
//# sourceMappingURL=parser.js.map