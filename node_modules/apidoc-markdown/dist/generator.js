"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMarkdownFileSystem = exports.generateMarkdown = exports.generate = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const gt_1 = __importDefault(require("semver/functions/gt"));
const utils_1 = require("./utils");
/**
 * Get the documentation generator
 *
 * @param param0 Documentation generator parameters
 * @returns The single or multi file EJS compiler, ready for usage
 */
const generate = async ({ apiDocProjectData, apiDocApiData, prepend, multi, header, footer, ejsCompiler }) => {
    // const { apiData, projectData, ejsCompiler } = await loadApiDocProject({ apiDocPath, template, prepend })
    // Define template data
    let apiByGroupAndName;
    // Group apiDoc data by group and name
    apiByGroupAndName = utils_1.unique(Object.values(apiDocApiData).map(x => x.group))
        .reduce((acc, cur) => {
        if (apiDocApiData.find(x => x.group === cur))
            acc.push({ name: cur, subs: [] });
        return acc;
    }, [])
        .map((g) => {
        apiDocApiData.forEach(x => x.group === g.name && g.subs.push(x));
        return g;
    })
        .map((g) => {
        g.subs = Object.values(g.subs.reduce((acc, cur) => {
            if (!acc[cur.title] || gt_1.default(cur.version, acc[cur.title].version))
                acc[cur.title] = cur;
            return acc;
        }, {}));
        return g;
    });
    // Sort entries by group name and title ascending
    apiByGroupAndName = apiByGroupAndName.sort((a, b) => a.name.localeCompare(b.name));
    apiByGroupAndName.forEach(x => x.subs.sort((a, b) => a.title.localeCompare(b.title)));
    // Order using the project order setting
    if (apiDocProjectData.order) {
        // Lowercased project order setting array
        const orderLowerCase = apiDocProjectData.order.map((x) => x.toLowerCase());
        // Filter items in/not in the project order setting array
        const inOrderArr = [];
        const notInOrderArr = [];
        apiByGroupAndName.forEach(x => orderLowerCase.indexOf(x.name.toLowerCase()) === -1 ? notInOrderArr.push(x) : inOrderArr.push(x));
        // Sorted, with the ones not in the project order setting array appended to it
        apiByGroupAndName = [
            ...inOrderArr.sort((a, b) => {
                const aIndex = orderLowerCase.indexOf(a.name.toLowerCase());
                const bIndex = orderLowerCase.indexOf(b.name.toLowerCase());
                if (aIndex === -1 && bIndex === -1)
                    return 0;
                return aIndex > bIndex ? 1 : -1;
            }),
            ...notInOrderArr
        ];
    }
    // This is the config passed to the template
    const templateConfig = {
        // Every functions in `utils_template.js` are passed to the EJS compiler
        ...utils_1.templateUtils,
        project: apiDocProjectData,
        header,
        footer,
        prepend
    };
    return !multi
        ? [{ name: 'main', content: await ejsCompiler({ ...templateConfig, data: apiByGroupAndName }) }]
        : await Promise.all(apiByGroupAndName.map(async (x) => ({
            name: x.name,
            content: await ejsCompiler({ ...templateConfig, data: [x] })
        })));
};
exports.generate = generate;
/**
 * Generate mardown documentation.
 *
 * @param param0 Generator configuration
 * @returns Generated documentation
 */
const generateMarkdown = async ({ apiDocProjectData, apiDocApiData, template, prepend, header, footer, multi }) => exports.generate({
    apiDocProjectData,
    apiDocApiData,
    header,
    footer,
    prepend,
    multi,
    ejsCompiler: await utils_1.loadTemplate(template, false)
});
exports.generateMarkdown = generateMarkdown;
/**
 * Generate mardown documentation and create output file(s).
 *
 * @param param0 Generator configuration
 * @returns Generated documentation
 * @throws Some CLI command parameters are missing or invalid
 */
const generateMarkdownFileSystem = async ({ apiDocPath, output, template, prepend, header, footer, multi, createPath }) => {
    // Check the apiDoc data path exists
    if (!apiDocPath)
        throw new Error('`cli.apiDocPath` is required but was not provided.');
    if (!(await utils_1.pathExists(apiDocPath)))
        throw new Error(`The \`cli.apiDocPath\` path does not exist or is not readable. Path: ${apiDocPath}`);
    // Check the output path exists (only parent directory if unique file)
    if (!output)
        throw new Error('`cli.output` is required but was not provided.');
    // Recursively create directory arborescence if cli option is true
    if (createPath)
        await utils_1.mkdirp(output.toLowerCase().endsWith('.md') ? path_1.default.dirname(output) : output);
    const outputPath = multi ? output : path_1.default.parse(path_1.default.resolve('.', output)).dir;
    if (!(await utils_1.pathExists(outputPath)))
        throw new Error(`The \`cli.output\` path does not exist or is not readable. Path: ${outputPath}`);
    const { apiDocProjectData, apiDocApiData } = await utils_1.loadApidocFiles(apiDocPath);
    // Check header, footer and prepend file path exist
    header = await utils_1.loadFromCliParamOrApiDocProject('header', header, apiDocProjectData);
    footer = await utils_1.loadFromCliParamOrApiDocProject('footer', footer, apiDocProjectData);
    prepend = await utils_1.loadFromCliParamOrApiDocProject('prepend', prepend, apiDocProjectData);
    // Generate the actual documentation
    const documentation = await exports.generate({
        apiDocProjectData,
        apiDocApiData,
        header,
        footer,
        prepend,
        multi,
        ejsCompiler: await utils_1.loadTemplate(template)
    });
    // Create the output files
    if (!multi) {
        // Single file documentation generation
        const singleDoc = documentation[0].content;
        await fs_1.promises.writeFile(output, singleDoc);
        return [{ outputFile: output, content: singleDoc }];
    }
    // Multi file documentation generation
    return Promise.all(documentation.map(async (aDoc) => {
        const filePath = path_1.default.resolve(outputPath, `${aDoc.name}.md`);
        await fs_1.promises.writeFile(filePath, aDoc.content);
        return { outputFile: filePath, content: aDoc.content };
    }));
};
exports.generateMarkdownFileSystem = generateMarkdownFileSystem;
