function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */
import chroma from 'chroma-js';

/**
 * Resolves a target URL path relative to the host.
 * This is specifically useed by the Kibana proxy re-routing.
 * It also handles trailing slashes in tileApiUrl and fileApiUrl parameters.
 */
export function toAbsoluteUrl(host, path) {
  if (!host) {
    return path;
  }

  var hostEndWithSlash = host[host.length - 1] === '/';
  var pathStartsWithSlash = path[0] === '/';

  if (hostEndWithSlash === true && pathStartsWithSlash === true) {
    return host + path.slice(1);
  } else if (hostEndWithSlash !== pathStartsWithSlash) {
    return host + path;
  } else {
    return host + '/' + path;
  }
}
/*
Type with the possible ways to define a color in maplibre
*/

/*
Function to transform a maplibre color definition by a given function.
*/
function transformColor(paintColor, func) {
  if (typeof paintColor == 'string') {
    var modifiedColor = func(paintColor);
    return "rgba(".concat(modifiedColor.rgba().join(','), ")");
  } else if (_typeof(paintColor) == 'object' && 'stops' in paintColor && Array.isArray(paintColor === null || paintColor === void 0 ? void 0 : paintColor.stops)) {
    var stops = paintColor['stops'].map(function (stop) {
      var newColor = transformColor(stop[1], func);
      return [stop[0], newColor];
    });
    var newPaintColor = Object.assign({}, paintColor, {
      stops: stops
    });
    return newPaintColor;
  } else return paintColor;
}
/*
This is the function used to generate the current EMS desaturated roadmap
*/


export function desaturateColor(paintColor) {
  return transformColor(paintColor, function (color) {
    return chroma(color).desaturate(1.1).brighten(0.33);
  });
}
/*
Blends an original maplibre color definition with a destination
color. Accepts different blending modes and an additional `mix`
option that needs a percentage.

More details: 

https://gka.github.io/chroma.js/#chroma-blend
https://gka.github.io/chroma.js/#chroma-mix
*/

export function colorizeColor(sourceColor, destColor) {
  var operation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'screen';
  var percentage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
  return transformColor(sourceColor, function (color) {
    if (operation !== 'mix') {
      return chroma.blend(chroma(color), destColor, operation);
    } else {
      return chroma.mix(chroma(color), destColor, percentage);
    }
  });
}