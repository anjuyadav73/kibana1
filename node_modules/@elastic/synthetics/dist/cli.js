#!/usr/bin/env node
"use strict";
/**
 * MIT License
 *
 * Copyright (c) 2020-present, Elastic NV
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const process_1 = require("process");
const path_1 = require("path");
const deepmerge_1 = __importDefault(require("deepmerge"));
const core_1 = require("./core");
const logger_1 = require("./core/logger");
const parse_args_1 = __importStar(require("./parse_args"));
const expect_1 = require("./core/expect");
const helpers_1 = require("./helpers");
const _1 = require("./");
const config_1 = require("./config");
const resolvedCwd = (0, process_1.cwd)();
/**
 * Set debug based on DEBUG ENV and -d flags
 * namespace - synthetics
 */
const namespace = 'synthetics';
if (process.env.DEBUG === namespace || Boolean(parse_args_1.options.debug)) {
    process.env.DEBUG = '1';
}
const loadInlineScript = source => {
    const scriptFn = new Function('step', 'page', 'context', 'browser', 'params', 'expect', source);
    (0, core_1.journey)('inline', ({ page, context, browser, params }) => {
        scriptFn.apply(null, [core_1.step, page, context, browser, params, expect_1.expect]);
    });
};
async function readStdin() {
    const chunks = [];
    process_1.stdin.resume();
    process_1.stdin.setEncoding('utf-8');
    for await (const chunk of process_1.stdin) {
        chunks.push(chunk);
    }
    return chunks.join();
}
function requireSuites(suites) {
    for (const suite of suites) {
        require(suite);
    }
}
/**
 * Handle both directory and files that are passed through TTY
 * and add them to suites
 */
async function prepareSuites(inputs) {
    const suites = new Set();
    const addSuite = absPath => {
        (0, logger_1.log)(`Processing file: ${absPath}`);
        suites.add(require.resolve(absPath));
    };
    /**
     * Match all files inside the directory with the
     * .journey.{mjs|cjs|js|ts) extensions
     */
    const pattern = parse_args_1.options.pattern
        ? new RegExp(parse_args_1.options.pattern, 'i')
        : /.+\.journey\.([mc]js|[jt]s?)$/;
    /**
     * Ignore node_modules by default when running suites
     */
    const ignored = /node_modules/i;
    for (const input of inputs) {
        const absPath = (0, path_1.resolve)(resolvedCwd, input);
        /**
         * Validate for package.json file before running
         * the suites
         */
        (0, helpers_1.findPkgJsonByTraversing)(absPath, resolvedCwd);
        if ((0, helpers_1.isDirectory)(absPath)) {
            await (0, helpers_1.totalist)(absPath, (rel, abs) => {
                if (pattern.test(rel) && !ignored.test(rel)) {
                    addSuite(abs);
                }
            });
        }
        else {
            addSuite(absPath);
        }
    }
    return suites.values();
}
(async () => {
    /**
     * Transform `.ts` files out of the box by invoking
     * the `ts-node` via `transpile-only` mode that compiles
     * TS files without doing any extensive type checks.
     *
     * We must register `ts-node` _before_ loading inline
     * scripts too because otherwise we will not be able to
     * require `.ts` configuration files.
     */
    /* eslint-disable-next-line @typescript-eslint/no-var-requires */
    require('ts-node').register({
        transpileOnly: true,
        compilerOptions: {
            esModuleInterop: true,
            allowJs: true,
            target: 'es2018',
        },
    });
    if (parse_args_1.options.inline) {
        const source = await readStdin();
        loadInlineScript(source);
    }
    else {
        /**
         * Preload modules before running the suites
         */
        const modules = [].concat(parse_args_1.options.require || []).filter(Boolean);
        for (const name of modules) {
            if ((0, helpers_1.isDepInstalled)(name)) {
                require(name);
            }
            else {
                throw new Error(`cannot find module '${name}'`);
            }
        }
        /**
         * Handle piped files by reading the STDIN
         * ex: ls example/suites/*.js | npx @elastic/synthetics
         */
        const files = parse_args_1.default.args.length > 0
            ? parse_args_1.default.args
            : (await readStdin()).split('\n').filter(Boolean);
        const suites = await prepareSuites(files);
        requireSuites(suites);
    }
    /**
     * Use the NODE_ENV variable to control the environment
     */
    const environment = process.env['NODE_ENV'] || 'development';
    /**
     * Validate and handle configs
     */
    const config = parse_args_1.options.config || !parse_args_1.options.inline
        ? (0, config_1.readConfig)(environment, parse_args_1.options.config)
        : {};
    const params = (0, deepmerge_1.default)(config.params, parse_args_1.options.params || {});
    /**
     * Favor playwright options passed via cli to inline playwright options
     */
    const playwrightOptions = deepmerge_1.default.all([
        config.playwrightOptions || {},
        parse_args_1.options.playwrightOptions || {},
        {
            headless: parse_args_1.options.headless,
            chromiumSandbox: parse_args_1.options.sandbox,
            ignoreHTTPSErrors: parse_args_1.options.ignoreHttpsErrors,
        },
    ]);
    const results = await (0, _1.run)({
        params: Object.freeze(params),
        networkConditions: parse_args_1.options.throttling
            ? (0, helpers_1.parseNetworkConditions)(parse_args_1.options.throttling)
            : undefined,
        environment,
        playwrightOptions,
        ...parse_args_1.options,
    });
    if (!parse_args_1.options.quietExitCode) {
        /**
         * Exit with error status if any journey fails
         */
        for (const result of Object.values(results)) {
            if (result.status === 'failed') {
                process.exit(1);
            }
        }
    }
})().catch(e => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map