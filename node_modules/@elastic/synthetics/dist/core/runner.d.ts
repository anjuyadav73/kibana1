/**
 * MIT License
 *
 * Copyright (c) 2020-present, Elastic NV
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
/// <reference types="node" />
import { EventEmitter } from 'events';
import { Journey } from '../dsl/journey';
import { Step } from '../dsl/step';
import { Reporter } from '../reporters';
import { StatusValue, HooksCallback, Params, NetworkConditions, PluginOutput, CliArgs, HooksArgs, PlaywrightOptions, Driver } from '../common_types';
import { PageMetrics, PluginManager } from '../plugins';
export declare type RunOptions = Omit<CliArgs, 'debug' | 'pattern' | 'inline' | 'require' | 'reporter' | 'richEvents' | 'capability' | 'sandbox' | 'headless' | 'throttling'> & {
    environment?: string;
    playwrightOptions?: PlaywrightOptions;
    networkConditions?: NetworkConditions;
    reporter?: CliArgs['reporter'] | Reporter;
};
declare type HookType = 'beforeAll' | 'afterAll';
export declare type SuiteHooks = Record<HookType, Array<HooksCallback>>;
declare type JourneyContext = {
    params?: Params;
    start: number;
    driver: Driver;
    pluginManager: PluginManager;
};
declare type StepResult = {
    status: StatusValue;
    url?: string;
    error?: Error;
    pagemetrics?: PageMetrics;
    filmstrips?: PluginOutput['filmstrips'];
    metrics?: PluginOutput['metrics'];
    traces?: PluginOutput['traces'];
};
declare type JourneyResult = {
    status: StatusValue;
    error?: Error;
    networkinfo?: PluginOutput['networkinfo'];
    browserconsole?: PluginOutput['browserconsole'];
};
declare type RunResult = Record<string, JourneyResult>;
interface StepEvent {
    step: Step;
    journey: Journey;
}
interface JourneyEvent {
    journey: Journey;
    timestamp: number;
    params?: Params;
}
interface Events {
    start: {
        numJourneys: number;
        networkConditions?: NetworkConditions;
    };
    'journey:register': {
        journey: Journey;
    };
    'journey:start': JourneyEvent;
    'journey:end': JourneyEvent & JourneyResult & {
        start: number;
        end: number;
        options: RunOptions;
        timestamp: number;
    };
    'journey:end:reported': unknown;
    'step:start': StepEvent;
    'step:end': StepEvent & StepResult & {
        start: number;
        end: number;
    };
    end: unknown;
}
export default interface Runner {
    on<K extends keyof Events>(name: K, listener: (v: Events[K]) => void): this;
    emit<K extends keyof Events>(event: K, args: Events[K]): boolean;
}
export default class Runner extends EventEmitter {
    active: boolean;
    currentJourney?: Journey;
    journeys: Journey[];
    hooks: SuiteHooks;
    hookError: Error | undefined;
    static screenshotPath: string;
    static createContext(options: RunOptions): Promise<JourneyContext>;
    captureScreenshot(page: Driver['page'], step: Step): Promise<void>;
    addHook(type: HookType, callback: HooksCallback): void;
    addJourney(journey: Journey): void;
    runBeforeAllHook(args: HooksArgs): Promise<void>;
    runAfterAllHook(args: HooksArgs): Promise<void>;
    runBeforeHook(journey: Journey, args: HooksArgs): Promise<void>;
    runAfterHook(journey: Journey, args: HooksArgs): Promise<void>;
    runStep(step: Step, context: JourneyContext, options: RunOptions): Promise<StepResult>;
    runSteps(journey: Journey, context: JourneyContext, options: RunOptions): Promise<StepResult[]>;
    registerJourney(journey: Journey, context: JourneyContext): void;
    endJourney(journey: any, result: JourneyContext & JourneyResult, options: RunOptions): Promise<void>;
    /**
     * Simulate a journey run to capture errors in the beforeAll hook
     */
    runFakeJourney(journey: Journey, options: RunOptions): Promise<JourneyResult>;
    runJourney(journey: Journey, options: RunOptions): Promise<JourneyResult>;
    init(options: RunOptions): Promise<void>;
    run(options: RunOptions): Promise<RunResult>;
    reset(): Promise<void>;
}
export {};
//# sourceMappingURL=runner.d.ts.map