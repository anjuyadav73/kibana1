{"version":3,"sources":["../../../../src/lib/parsers/parse-shp.js"],"names":["BinaryChunkReader","parseSHPHeader","parseRecord","LITTLE_ENDIAN","BIG_ENDIAN","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","STATE","EXPECTING_HEADER","EXPECTING_RECORD","END","ERROR","SHPParser","constructor","options","binaryReader","maxRewindBytes","state","result","geometries","write","arrayBuffer","parseState","end","error","parseSHP","shpParser","parseSHPInBatches","asyncIterator","parser","headerReturned","header","length","dataView","getDataView","progress","bytesUsed","bytesTotal","rows","currentIndex","hasAvailableBytes","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","rewind","invalidRecord","recordView","geometry","push","ended","message"],"mappings":"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","sourcesContent":["import BinaryChunkReader from '../streaming/binary-chunk-reader';\nimport {parseSHPHeader} from './parse-shp-header';\nimport {parseRecord} from './parse-shp-geometry';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 12;\n\nconst STATE = {\n  EXPECTING_HEADER: 0,\n  EXPECTING_RECORD: 1,\n  END: 2,\n  ERROR: 3\n};\n\nclass SHPParser {\n  constructor(options) {\n    this.options = options;\n    this.binaryReader = new BinaryChunkReader({maxRewindBytes: SHP_RECORD_HEADER_SIZE});\n    this.state = STATE.EXPECTING_HEADER;\n    this.result = {\n      geometries: []\n    };\n  }\n\n  write(arrayBuffer) {\n    this.binaryReader.write(arrayBuffer);\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n  }\n\n  end() {\n    this.binaryReader.end();\n    this.state = parseState(this.state, this.result, this.binaryReader, this.options);\n    // this.result.progress.bytesUsed = this.binaryReader.bytesUsed();\n    if (this.state !== STATE.END) {\n      this.state = STATE.ERROR;\n      this.result.error = 'SHP incomplete file';\n    }\n  }\n}\n\nexport function parseSHP(arrayBuffer, options) {\n  const shpParser = new SHPParser(options);\n  shpParser.write(arrayBuffer);\n  shpParser.end();\n\n  return shpParser.result;\n}\n\nexport async function* parseSHPInBatches(asyncIterator, options) {\n  const parser = new SHPParser(options);\n  let headerReturned = false;\n  for await (const arrayBuffer of asyncIterator) {\n    parser.write(arrayBuffer);\n    if (!headerReturned && parser.result.header) {\n      headerReturned = true;\n      yield parser.result.header;\n    }\n\n    if (parser.result.geometries.length > 0) {\n      yield parser.result.geometries;\n      parser.result.geometries = [];\n    }\n  }\n  parser.end();\n  if (parser.result.geometries.length > 0) {\n    yield parser.result.geometries;\n  }\n\n  return;\n}\n\n/**\n * State-machine parser for SHP data\n *\n * Note that whenever more data is needed, a `return`, not a `break`, is\n * necessary, as the `break` keeps the context within `parseState`, while\n * `return` releases context so that more data can be written into the\n * BinaryChunkReader.\n *\n * @param  {Number} state Current state\n * @param  {Object} [result={}]  An object to hold result data\n * @param  {BinaryChunkReader} binaryReader\n * @return {Number} State at end of current parsing\n */\n/* eslint-disable complexity, max-depth */\nfunction parseState(state, result = {}, binaryReader, options) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    try {\n      switch (state) {\n        case STATE.ERROR:\n        case STATE.END:\n          return state;\n\n        case STATE.EXPECTING_HEADER:\n          // Parse initial file header\n          const dataView = binaryReader.getDataView(SHP_HEADER_SIZE);\n          if (!dataView) {\n            return state;\n          }\n\n          result.header = parseSHPHeader(dataView);\n          result.progress = {\n            bytesUsed: 0,\n            bytesTotal: result.header.length,\n            rows: 0\n          };\n          // index numbering starts at 1\n          result.currentIndex = 1;\n          state = STATE.EXPECTING_RECORD;\n          break;\n\n        case STATE.EXPECTING_RECORD:\n          while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE)) {\n            const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE);\n            const recordHeader = {\n              recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n              // 2 byte words; includes the four words of record header\n              byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n              // This is actually part of the record, not the header...\n              type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n            };\n\n            if (!binaryReader.hasAvailableBytes(recordHeader.byteLength - 4)) {\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n              return state;\n            }\n\n            const invalidRecord =\n              recordHeader.byteLength < 4 ||\n              recordHeader.type !== result.header.type ||\n              recordHeader.recordNumber !== result.currentIndex;\n\n            // All records must have at least four bytes (for the record shape type)\n            if (invalidRecord) {\n              // Malformed record, try again, advancing just 4 bytes\n              // Note: this is a rewind because binaryReader.getDataView above\n              // moved the pointer forward 12 bytes, so rewinding 8 bytes still\n              // leaves us 4 bytes ahead\n              binaryReader.rewind(SHP_RECORD_HEADER_SIZE - 4);\n            } else {\n              // Note: type is actually part of the record, not the header, so\n              // rewind 4 bytes before reading record\n              binaryReader.rewind(4);\n\n              const recordView = binaryReader.getDataView(recordHeader.byteLength);\n              const geometry = parseRecord(recordView, options);\n              result.geometries.push(geometry);\n\n              result.currentIndex++;\n              result.progress.rows = result.currentIndex - 1;\n            }\n          }\n\n          if (binaryReader.ended) {\n            state = STATE.END;\n          }\n\n          return state;\n\n        default:\n          state = STATE.ERROR;\n          result.error = `illegal parser state ${state}`;\n          return state;\n      }\n    } catch (error) {\n      state = STATE.ERROR;\n      result.error = `SHP parsing failed: ${error.message}`;\n      return state;\n    }\n  }\n}\n"],"file":"parse-shp.js"}