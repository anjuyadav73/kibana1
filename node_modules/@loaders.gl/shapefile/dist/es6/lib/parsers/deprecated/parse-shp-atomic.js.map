{"version":3,"sources":["../../../../../src/lib/parsers/deprecated/parse-shp-atomic.js"],"names":["BinaryReader","parseRecord","LITTLE_ENDIAN","BIG_ENDIAN","SHP_MAGIC_NUMBER","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","parseSHP","arrayBuffer","options","binaryReader","headerView","getDataView","header","parseSHPHeader","currentIndex","geometries","hasAvailableBytes","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","invalidRecord","rewind","recordView","push","magic","length","version","bbox","minX","getFloat64","minY","minZ","minM","maxX","maxY","maxZ","maxM","console","error"],"mappings":"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","sourcesContent":["import BinaryReader from '../../streaming/binary-reader';\nimport {parseRecord} from '../parse-shp-geometry';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_MAGIC_NUMBER = 0x0000270a;\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 8;\n\n/**\n * Atomically parse a shapefile from an ArrayBuffer\n * @param {ArrayBuffer} arrayBuffer\n */\nexport default function parseSHP(arrayBuffer, options) {\n  const binaryReader = new BinaryReader(arrayBuffer);\n\n  const headerView = binaryReader.getDataView(SHP_HEADER_SIZE);\n  const header = parseSHPHeader(headerView);\n\n  // index numbering starts at 1\n  let currentIndex = 1;\n  const geometries = [];\n\n  while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE + 4)) {\n    const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE + 4);\n    const recordHeader = {\n      recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n      // 2 byte words; includes the four words of record header\n      byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n      // This is actually part of the record, not the header...\n      type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n    };\n\n    const invalidRecord =\n      recordHeader.byteLength < 4 ||\n      recordHeader.type !== header.type ||\n      recordHeader.recordNumber !== currentIndex;\n\n    // All records must have at least four bytes (for the record shape type)\n    if (invalidRecord) {\n      // Malformed record, try again, advancing just 4 bytes\n      binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n    } else {\n      // Note: type is actually part of the record, not the header, so rewind 4 bytes befor reading record\n      binaryReader.rewind(4);\n\n      const recordView = binaryReader.getDataView(recordHeader.byteLength);\n      geometries.push(parseRecord(recordView, options));\n      currentIndex++;\n    }\n  }\n\n  return {\n    header,\n    geometries\n  };\n}\n\n/**\n * Extract the binary header\n * @param {DataView} headerView\n */\nexport function parseSHPHeader(headerView) {\n  // Note: The SHP format switches endianness between fields!\n  // https://www.esri.com/library/whitepapers/pdfs/shapefile.pdf\n  const header = {\n    magic: headerView.getInt32(0, BIG_ENDIAN),\n    // Length is stored as # of 2-byte words; multiply by 2 to get # of bytes\n    length: headerView.getInt32(24, BIG_ENDIAN) * 2,\n    version: headerView.getInt32(28, LITTLE_ENDIAN),\n    type: headerView.getInt32(32, LITTLE_ENDIAN),\n    bbox: {\n      minX: headerView.getFloat64(36, LITTLE_ENDIAN),\n      minY: headerView.getFloat64(44, LITTLE_ENDIAN),\n      minZ: headerView.getFloat64(68, LITTLE_ENDIAN),\n      minM: headerView.getFloat64(84, LITTLE_ENDIAN),\n      maxX: headerView.getFloat64(52, LITTLE_ENDIAN),\n      maxY: headerView.getFloat64(60, LITTLE_ENDIAN),\n      maxZ: headerView.getFloat64(76, LITTLE_ENDIAN),\n      maxM: headerView.getFloat64(92, LITTLE_ENDIAN)\n    }\n  };\n  if (header.magic !== SHP_MAGIC_NUMBER) {\n    // eslint-disable-next-line\n    console.error(`SHP file: bad magic number ${header.magic}`);\n  }\n  if (header.version !== 1000) {\n    // eslint-disable-next-line\n    console.error(`SHP file: bad version ${header.version}`);\n  }\n  return header;\n}\n"],"file":"parse-shp-atomic.js"}