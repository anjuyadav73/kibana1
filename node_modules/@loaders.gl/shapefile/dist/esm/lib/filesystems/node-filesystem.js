import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import fs from 'fs';
import util from 'util';

var NodeFileSystem = function () {
  function NodeFileSystem() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, NodeFileSystem);

    this._fetch = options.fetch;
  }

  _createClass(NodeFileSystem, [{
    key: "readdir",
    value: function () {
      var _readdir = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {
        var path,
            options,
            readdir,
            _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                path = _args.length > 0 && _args[0] !== undefined ? _args[0] : '.';
                options = _args.length > 1 ? _args[1] : undefined;
                readdir = util.promisify(fs.readdir);
                _context.next = 5;
                return readdir(path, options);

              case 5:
                return _context.abrupt("return", _context.sent);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function readdir() {
        return _readdir.apply(this, arguments);
      }

      return readdir;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(path, options) {
        var stat, info;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                stat = util.promisify(fs.stat);
                _context2.next = 3;
                return stat(path, options);

              case 3:
                info = _context2.sent;
                return _context2.abrupt("return", {
                  size: Number(info.size),
                  isDirectory: function isDirectory() {
                    return false;
                  },
                  info: info
                });

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function stat(_x, _x2) {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }, {
    key: "fetch",
    value: function () {
      var _fetch = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(path) {
        var options,
            fallbackFetch,
            _args3 = arguments;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                fallbackFetch = options.fetch || this._fetch;
                return _context3.abrupt("return", fallbackFetch(path, options));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function fetch(_x3) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "open",
    value: function () {
      var _open = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(path, flags, mode) {
        var open;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                open = util.promisify(fs.open);
                _context4.next = 3;
                return open(path, flags);

              case 3:
                return _context4.abrupt("return", _context4.sent);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function open(_x4, _x5, _x6) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(fd) {
        var close;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                close = util.promisify(fs.close);
                _context5.next = 3;
                return close(fd);

              case 3:
                return _context5.abrupt("return", _context5.sent);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function close(_x7) {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "fstat",
    value: function () {
      var _fstat = _asyncToGenerator(_regeneratorRuntime.mark(function _callee6(fd) {
        var fstat, info;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                fstat = util.promisify(fs.fstat);
                _context6.next = 3;
                return fstat(fd);

              case 3:
                info = _context6.sent;
                return _context6.abrupt("return", info);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }));

      function fstat(_x8) {
        return _fstat.apply(this, arguments);
      }

      return fstat;
    }()
  }, {
    key: "read",
    value: function () {
      var _read = _asyncToGenerator(_regeneratorRuntime.mark(function _callee7(fd, _ref) {
        var _ref$buffer, buffer, _ref$offset, offset, _ref$length, length, _ref$position, position, fsRead, totalBytesRead, _yield$fsRead, bytesRead;

        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _ref$buffer = _ref.buffer, buffer = _ref$buffer === void 0 ? null : _ref$buffer, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset, _ref$length = _ref.length, length = _ref$length === void 0 ? buffer.byteLength : _ref$length, _ref$position = _ref.position, position = _ref$position === void 0 ? null : _ref$position;
                fsRead = util.promisify(fs.read);
                totalBytesRead = 0;

              case 3:
                if (!(totalBytesRead < length)) {
                  _context7.next = 11;
                  break;
                }

                _context7.next = 6;
                return fsRead(fd, buffer, offset + totalBytesRead, length - totalBytesRead, position + totalBytesRead);

              case 6:
                _yield$fsRead = _context7.sent;
                bytesRead = _yield$fsRead.bytesRead;
                totalBytesRead += bytesRead;
                _context7.next = 3;
                break;

              case 11:
                return _context7.abrupt("return", {
                  bytesRead: totalBytesRead,
                  buffer: buffer
                });

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function read(_x9, _x10) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }]);

  return NodeFileSystem;
}();

export { NodeFileSystem as default };
//# sourceMappingURL=node-filesystem.js.map