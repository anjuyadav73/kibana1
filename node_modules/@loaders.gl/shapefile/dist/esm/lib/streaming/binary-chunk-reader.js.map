{"version":3,"sources":["../../../../src/lib/streaming/binary-chunk-reader.js"],"names":["BinaryChunkReader","options","maxRewindBytes","offset","arrayBuffers","ended","arrayBuffer","push","bytes","bytesAvailable","byteLength","selectedBuffers","i","length","buf","start","Math","abs","end","bufferOffsets","findBufferOffsets","Error","bufferIndex","view","DataView","disposeBuffers","_combineArrayBuffers","shift","bufferOffset","result","Uint8Array","resultOffset","sourceArray","set","subarray","buffer"],"mappings":"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","sourcesContent":["export default class BinaryChunkReader {\n  constructor(options) {\n    const {maxRewindBytes = 0} = options || {};\n\n    /** current global offset into current array buffer*/\n    this.offset = 0;\n    /** current buffer from iterator */\n    this.arrayBuffers = [];\n    this.ended = false;\n\n    /** bytes behind offset to hold on to */\n    this.maxRewindBytes = maxRewindBytes;\n  }\n\n  write(arrayBuffer) {\n    this.arrayBuffers.push(arrayBuffer);\n  }\n\n  end() {\n    this.arrayBuffers = [];\n    this.ended = true;\n  }\n\n  /**\n   * Has enough bytes available in array buffers\n   *\n   * @param  {Number}  bytes Number of bytes\n   * @return {Boolean}\n   */\n  hasAvailableBytes(bytes) {\n    let bytesAvailable = -this.offset;\n    for (const arrayBuffer of this.arrayBuffers) {\n      bytesAvailable += arrayBuffer.byteLength;\n      if (bytesAvailable >= bytes) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Find offsets of byte ranges within this.arrayBuffers\n   *\n   * @param  {Number} bytes Byte length to read\n   * @return {any} Arrays with byte ranges pointing to this.arrayBuffers\n   */\n  findBufferOffsets(bytes) {\n    let offset = -this.offset;\n    const selectedBuffers = [];\n\n    for (let i = 0; i < this.arrayBuffers.length; i++) {\n      const buf = this.arrayBuffers[i];\n\n      // Current buffer isn't long enough to reach global offset\n      if (offset + buf.byteLength <= 0) {\n        offset += buf.byteLength;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Find start/end offsets for this buffer\n      // When offset < 0, need to skip over Math.abs(offset) bytes\n      // When offset > 0, implies bytes in previous buffer, start at 0\n      const start = offset <= 0 ? Math.abs(offset) : 0;\n      let end;\n\n      // Length of requested bytes is contained in current buffer\n      if (start + bytes <= buf.byteLength) {\n        end = start + bytes;\n        selectedBuffers.push([i, [start, end]]);\n        return selectedBuffers;\n      }\n\n      // Will need to look into next buffer\n      end = buf.byteLength;\n      selectedBuffers.push([i, [start, end]]);\n\n      // Need to read fewer bytes in next iter\n      bytes -= buf.byteLength - start;\n      offset += buf.byteLength;\n    }\n\n    // Should only finish loop if exhausted all arrays\n    return null;\n  }\n\n  /**\n   * Get the required number of bytes from the iterator\n   *\n   * @param  {Number} bytes Number of bytes\n   * @return {DataView?}     DataView with data\n   */\n  getDataView(bytes) {\n    const bufferOffsets = this.findBufferOffsets(bytes);\n    // return `null` if not enough data, except if end() already called, in\n    // which case throw an error.\n    if (!bufferOffsets && this.ended) {\n      throw new Error('binary data exhausted');\n    }\n    if (!bufferOffsets) {\n      return null;\n    }\n\n    // If only one arrayBuffer needed, return DataView directly\n    if (bufferOffsets.length === 1) {\n      const [bufferIndex, [start, end]] = bufferOffsets[0];\n      const arrayBuffer = this.arrayBuffers[bufferIndex];\n      const view = new DataView(arrayBuffer, start, end - start);\n\n      this.offset += bytes;\n      this.disposeBuffers();\n      return view;\n    }\n\n    // Concatenate portions of multiple ArrayBuffers\n    const view = new DataView(this._combineArrayBuffers(bufferOffsets));\n    this.offset += bytes;\n    this.disposeBuffers();\n    return view;\n  }\n\n  /**\n   * Dispose of old array buffers\n   */\n  disposeBuffers() {\n    while (\n      this.arrayBuffers.length > 0 &&\n      this.offset - this.maxRewindBytes >= this.arrayBuffers[0].byteLength\n    ) {\n      this.offset -= this.arrayBuffers[0].byteLength;\n      this.arrayBuffers.shift();\n    }\n  }\n\n  /**\n   * Copy multiple ArrayBuffers into one contiguous ArrayBuffer\n   *\n   * In contrast to concatenateArrayBuffers, this only copies the necessary\n   * portions of the source arrays, rather than first copying the entire arrays\n   * then taking a part of them.\n   *\n   * @param  {any} bufferOffsets List of internal array offsets\n   * @return {ArrayBuffer}       New contiguous ArrayBuffer\n   */\n  _combineArrayBuffers(bufferOffsets) {\n    let byteLength = 0;\n    for (const bufferOffset of bufferOffsets) {\n      const [start, end] = bufferOffset[1];\n      byteLength += end - start;\n    }\n\n    const result = new Uint8Array(byteLength);\n\n    // Copy the subarrays\n    let resultOffset = 0;\n    for (const bufferOffset of bufferOffsets) {\n      const [bufferIndex, [start, end]] = bufferOffset;\n      const sourceArray = new Uint8Array(this.arrayBuffers[bufferIndex]);\n      result.set(sourceArray.subarray(start, end), resultOffset);\n      resultOffset += end - start;\n    }\n\n    return result.buffer;\n  }\n\n  skip(bytes) {\n    this.offset += bytes;\n  }\n\n  rewind(bytes) {\n    // TODO - only works if offset is already set\n    this.offset -= bytes;\n  }\n}\n"],"file":"binary-chunk-reader.js"}