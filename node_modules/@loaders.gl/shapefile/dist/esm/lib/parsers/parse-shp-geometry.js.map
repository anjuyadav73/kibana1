{"version":3,"sources":["../../../../src/lib/parsers/parse-shp-geometry.js"],"names":["LITTLE_ENDIAN","parseRecord","view","options","shp","_maxDimensions","offset","type","getInt32","Int32Array","BYTES_PER_ELEMENT","parseNull","parsePoint","Math","min","parsePoly","parseMultiPoint","Error","dim","positions","parsePositions","value","size","Float64Array","nPoints","xyPositions","mPositions","zPositions","concatPositions","nParts","bufferOffset","byteOffset","bufferLength","ringIndices","set","buffer","slice","pathIndices","polygonIndices","i","length","startRingIndex","endRingIndex","ring","subarray","sign","getWindingDirection","push","primitivePolygonIndices","Uint32Array","arrayLength","nDim","getSignedArea","area","nCoords"],"mappings":"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","sourcesContent":["const LITTLE_ENDIAN = true;\n\n/**\n * Parse individual record\n *\n * @param  {DataView} view Record data\n * @return {object} Binary Geometry Object\n */\n// eslint-disable-next-line complexity\nexport function parseRecord(view, options) {\n  const {_maxDimensions} = (options && options.shp) || {};\n\n  let offset = 0;\n  const type = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  switch (type) {\n    case 0:\n      // Null Shape\n      return parseNull();\n    case 1:\n      // Point\n      return parsePoint(view, offset, Math.min(2, _maxDimensions));\n    case 3:\n      // PolyLine\n      return parsePoly(view, offset, Math.min(2, _maxDimensions), 'LineString');\n    case 5:\n      // Polygon\n      return parsePoly(view, offset, Math.min(2, _maxDimensions), 'Polygon');\n    case 8:\n      // MultiPoint\n      return parseMultiPoint(view, offset, Math.min(2, _maxDimensions));\n    // GeometryZ can have 3 or 4 dimensions, since the M is not required to\n    // exist\n    case 11:\n      // PointZ\n      return parsePoint(view, offset, Math.min(4, _maxDimensions));\n    case 13:\n      // PolyLineZ\n      return parsePoly(view, offset, Math.min(4, _maxDimensions), 'LineString');\n    case 15:\n      // PolygonZ\n      return parsePoly(view, offset, Math.min(4, _maxDimensions), 'Polygon');\n    case 18:\n      // MultiPointZ\n      return parseMultiPoint(view, offset, Math.min(4, _maxDimensions));\n    case 21:\n      // PointM\n      return parsePoint(view, offset, Math.min(3, _maxDimensions));\n    case 23:\n      // PolyLineM\n      return parsePoly(view, offset, Math.min(3, _maxDimensions), 'LineString');\n    case 25:\n      // PolygonM\n      return parsePoly(view, offset, Math.min(3, _maxDimensions), 'Polygon');\n    case 28:\n      // MultiPointM\n      return parseMultiPoint(view, offset, Math.min(3, _maxDimensions));\n    default:\n      throw new Error(`unsupported shape type: ${type}`);\n  }\n}\n\n// TODO handle null\n/**\n * Parse Null geometry\n *\n * @return {null}\n */\nfunction parseNull() {\n  return null;\n}\n\n/**\n * Parse point geometry\n *\n * @param  {DataView} view Geometry data\n * @param  {number} offset Offset in view\n * @param  {number} dim Dimension size\n * @return {object} Binary geometry object\n */\nfunction parsePoint(view, offset, dim) {\n  let positions;\n  [positions, offset] = parsePositions(view, offset, 1, dim);\n\n  return {\n    positions: {value: positions, size: dim},\n    type: 'Point'\n  };\n}\n\n/**\n * Parse MultiPoint geometry\n *\n * @param  {DataView} view Geometry data\n * @param  {number} offset Offset in view\n * @param  {number} dim Input dimension\n * @return {object} Binary geometry object\n */\nfunction parseMultiPoint(view, offset, dim) {\n  // skip parsing box\n  offset += 4 * Float64Array.BYTES_PER_ELEMENT;\n\n  const nPoints = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  let xyPositions = null;\n  let mPositions = null;\n  let zPositions = null;\n  [xyPositions, offset] = parsePositions(view, offset, nPoints, 2);\n\n  // Parse Z coordinates\n  if (dim === 4) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [zPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  // Parse M coordinates\n  if (dim >= 3) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [mPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  const positions = concatPositions(xyPositions, mPositions, zPositions);\n\n  return {\n    positions: {value: positions, size: dim},\n    type: 'Point'\n  };\n}\n\n/**\n * Polygon and PolyLine parsing\n *\n * @param  {DataView} view Geometry data\n * @param  {number} offset Offset in view\n * @param  {number} dim Input dimension\n * @param  {string} type Either 'Polygon' or 'Polyline'\n * @return {object} Binary geometry object\n */\n// eslint-disable-next-line max-statements\nfunction parsePoly(view, offset, dim, type) {\n  // skip parsing bounding box\n  offset += 4 * Float64Array.BYTES_PER_ELEMENT;\n\n  const nParts = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n  const nPoints = view.getInt32(offset, LITTLE_ENDIAN);\n  offset += Int32Array.BYTES_PER_ELEMENT;\n\n  // Create longer indices array by 1 because output format is expected to\n  // include the last index as the total number of positions\n  const bufferOffset = view.byteOffset + offset;\n  const bufferLength = nParts * Int32Array.BYTES_PER_ELEMENT;\n  const ringIndices = new Int32Array(nParts + 1);\n  ringIndices.set(new Int32Array(view.buffer.slice(bufferOffset, bufferOffset + bufferLength)));\n  ringIndices[nParts] = nPoints;\n  offset += nParts * Int32Array.BYTES_PER_ELEMENT;\n\n  let xyPositions = null;\n  let mPositions = null;\n  let zPositions = null;\n  [xyPositions, offset] = parsePositions(view, offset, nPoints, 2);\n\n  // Parse Z coordinates\n  if (dim === 4) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [zPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  // Parse M coordinates\n  if (dim >= 3) {\n    // skip parsing range\n    offset += 2 * Float64Array.BYTES_PER_ELEMENT;\n    [mPositions, offset] = parsePositions(view, offset, nPoints, 1);\n  }\n\n  const positions = concatPositions(xyPositions, mPositions, zPositions);\n\n  // parsePoly only accepts type = LineString or Polygon\n  if (type === 'LineString') {\n    return {\n      positions: {value: positions, size: dim},\n      pathIndices: {value: ringIndices, size: 1},\n      type\n    };\n  }\n\n  // for every ring, determine sign of polygon\n  // Use only 2D positions for ring calc\n  const polygonIndices = [];\n  for (let i = 1; i < ringIndices.length; i++) {\n    const startRingIndex = ringIndices[i - 1];\n    const endRingIndex = ringIndices[i];\n    const ring = xyPositions.subarray(startRingIndex * 2, endRingIndex * 2);\n    const sign = getWindingDirection(ring);\n\n    // A positive sign implies clockwise\n    // A clockwise ring is a filled ring\n    if (sign > 0) {\n      polygonIndices.push(startRingIndex);\n    }\n  }\n\n  polygonIndices.push(nPoints);\n\n  return {\n    positions: {value: positions, size: dim},\n    primitivePolygonIndices: {value: ringIndices, size: 1},\n    // TODO: Dynamically choose Uint32Array over Uint16Array only when\n    // necessary. I believe the implementation requires nPoints to be the\n    // largest value in the array, so you should be able to use Uint32Array only\n    // when nPoints > 65535.\n    polygonIndices: {value: new Uint32Array(polygonIndices), size: 1},\n    type\n  };\n}\n\n/**\n * Parse a contiguous block of positions into a Float64Array\n *\n * @param  {DataView} view  Geometry data\n * @param  {number} offset  Offset in view\n * @param  {number} nPoints Number of points\n * @param  {number} dim     Input dimension\n * @return {[Float64Array, number]} Data and offset\n */\nfunction parsePositions(view, offset, nPoints, dim) {\n  const bufferOffset = view.byteOffset + offset;\n  const bufferLength = nPoints * dim * Float64Array.BYTES_PER_ELEMENT;\n  return [\n    new Float64Array(view.buffer.slice(bufferOffset, bufferOffset + bufferLength)),\n    offset + bufferLength\n  ];\n}\n\n/**\n * Concatenate and interleave positions arrays\n * xy positions are interleaved; mPositions, zPositions are their own arrays\n *\n * @param  {Float64Array} xyPositions 2d positions\n * @param  {Float64Array?} mPositions  M positions\n * @param  {Float64Array?} zPositions  Z positions\n * @return {Float64Array} Combined interleaved positions\n */\n// eslint-disable-next-line complexity\nfunction concatPositions(xyPositions, mPositions, zPositions) {\n  if (!(mPositions || zPositions)) {\n    return xyPositions;\n  }\n\n  let arrayLength = xyPositions.length;\n  let nDim = 2;\n\n  if (zPositions && zPositions.length) {\n    arrayLength += zPositions.length;\n    nDim++;\n  }\n\n  if (mPositions && mPositions.length) {\n    arrayLength += mPositions.length;\n    nDim++;\n  }\n\n  const positions = new Float64Array(arrayLength);\n  for (let i = 0; i < xyPositions.length / 2; i++) {\n    positions[nDim * i] = xyPositions[i * 2];\n    positions[nDim * i + 1] = xyPositions[i * 2 + 1];\n  }\n\n  if (zPositions && zPositions.length) {\n    for (let i = 0; i < zPositions.length; i++) {\n      // If Z coordinates exist; used as third coord in positions array\n      positions[nDim * i + 2] = zPositions[i];\n    }\n  }\n\n  if (mPositions && mPositions.length) {\n    for (let i = 0; i < mPositions.length; i++) {\n      // M is always last, either 3rd or 4th depending on if Z exists\n      positions[nDim * i + (nDim - 1)] = mPositions[i];\n    }\n  }\n\n  return positions;\n}\n\n/**\n * Returns the direction of the polygon path\n * A positive number is clockwise.\n * A negative number is counter clockwise.\n *\n * @param  {Float64Array} positions\n * @return {number} Sign of polygon ring\n */\nfunction getWindingDirection(positions) {\n  return Math.sign(getSignedArea(positions));\n}\n\n/**\n * Get signed area of flat typed array of 2d positions\n *\n * @param  {Float64Array} positions\n * @return {number} Signed area of polygon ring\n */\nfunction getSignedArea(positions) {\n  let area = 0;\n\n  // Rings are closed according to shapefile spec\n  const nCoords = positions.length / 2 - 1;\n  for (let i = 0; i < nCoords; i++) {\n    area +=\n      (positions[i * 2] + positions[(i + 1) * 2]) *\n      (positions[i * 2 + 1] - positions[(i + 1) * 2 + 1]);\n  }\n\n  return area / 2;\n}\n"],"file":"parse-shp-geometry.js"}