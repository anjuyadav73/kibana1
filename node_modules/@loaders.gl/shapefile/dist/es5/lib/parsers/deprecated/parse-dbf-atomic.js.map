{"version":3,"sources":["../../../../../src/lib/parsers/deprecated/parse-dbf-atomic.js"],"names":["LITTLE_ENDIAN","DBF_HEADER_SIZE","parseDbf","arrayBuffer","options","binaryReader","BinaryReader","loaderOptions","dbf","encoding","fileHeaderView","getDataView","header","parseDBFHeader","headerLength","recordLength","nRecords","textDecoder","TextDecoder","colHeaderView","fields","parseColumnHeaders","skip","parseRows","headerView","year","getUint8","month","day","getUint32","getUint16","languageDriver","view","nFields","byteLength","offset","i","name","decode","Uint8Array","buffer","byteOffset","replace","push","dataType","String","fromCharCode","fieldLength","decimal","rows","recordView","parseRow","out","field","text","parseField","parseNumber","parseCharacter","parseDate","parseBoolean","Error","str","Date","UTC","slice","parseInt","value","test","number","parseFloat","isNaN","trim"],"mappings":"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","sourcesContent":["/* global TextDecoder */\nimport BinaryReader from '../../streaming/binary-reader';\n\nconst LITTLE_ENDIAN = true;\nconst DBF_HEADER_SIZE = 32;\n\nexport default function parseDbf(arrayBuffer, options) {\n  const binaryReader = new BinaryReader(arrayBuffer);\n\n  const loaderOptions = options.dbf || {};\n  const {encoding} = loaderOptions;\n\n  // Global header\n  const fileHeaderView = binaryReader.getDataView(DBF_HEADER_SIZE);\n  const header = parseDBFHeader(fileHeaderView);\n  const {headerLength, recordLength, nRecords} = header;\n\n  // Row headers\n  const textDecoder = new TextDecoder(encoding);\n  const colHeaderView = binaryReader.getDataView(headerLength - DBF_HEADER_SIZE);\n  const fields = parseColumnHeaders(colHeaderView, textDecoder);\n\n  // Not exactly sure why start offset needs to be headerLength + 1?\n  // parsedbf uses ((fields.length + 1) << 5) + 2;\n  binaryReader.skip(1);\n\n  return parseRows(binaryReader, fields, nRecords, recordLength, textDecoder);\n}\n\n/**\n * @param {DataView} headerView\n */\nfunction parseDBFHeader(headerView) {\n  return {\n    // Last updated date\n    year: headerView.getUint8(1) + 1900,\n    month: headerView.getUint8(2),\n    day: headerView.getUint8(3),\n    // Number of records in data file\n    nRecords: headerView.getUint32(4, LITTLE_ENDIAN),\n    // Length of header in bytes\n    headerLength: headerView.getUint16(8, LITTLE_ENDIAN),\n    // Length of each record\n    recordLength: headerView.getUint16(10, LITTLE_ENDIAN),\n    // Not sure if this is usually set\n    languageDriver: headerView.getUint8(29)\n  };\n}\n\n/**\n * @param {DataView} view\n */\nfunction parseColumnHeaders(view, textDecoder) {\n  // NOTE: this might overestimate the number of fields if the \"Database\n  // Container\" container exists and is included in the headerLength\n  const nFields = (view.byteLength - 1) / 32;\n  const fields = [];\n  let offset = 0;\n  for (let i = 0; i < nFields; i++) {\n    const name = textDecoder\n      .decode(new Uint8Array(view.buffer, view.byteOffset + offset, 11))\n      // eslint-disable-next-line no-control-regex\n      .replace(/\\u0000/g, '');\n\n    fields.push({\n      name,\n      dataType: String.fromCharCode(view.getUint8(offset + 11)),\n      fieldLength: view.getUint8(offset + 16),\n      decimal: view.getUint8(offset + 17)\n    });\n    offset += 32;\n  }\n  return fields;\n}\n\n/**\n * @param {BinaryReader} binaryReader\n */\nfunction parseRows(binaryReader, fields, nRecords, recordLength, textDecoder) {\n  const rows = [];\n  for (let i = 0; i < nRecords; i++) {\n    const recordView = binaryReader.getDataView(recordLength - 1);\n    binaryReader.skip(1);\n    rows.push(parseRow(recordView, fields, textDecoder));\n  }\n  return rows;\n}\n\n/**\n * @param {DataView} view\n */\nfunction parseRow(view, fields, textDecoder) {\n  const out = {};\n  let offset = 0;\n  for (const field of fields) {\n    const text = textDecoder.decode(\n      new Uint8Array(view.buffer, view.byteOffset + offset, field.fieldLength)\n    );\n    out[field.name] = parseField(text, field.dataType);\n    offset += field.fieldLength;\n  }\n\n  return out;\n}\n\n/**\n * Parse one field\n * @param {string} text\n * @param {*} dataType\n * @todo Should NaN be coerced to null?\n */\nfunction parseField(text, dataType) {\n  switch (dataType) {\n    case 'B':\n      return parseNumber(text);\n    case 'C':\n      return parseCharacter(text);\n    case 'F':\n      return parseNumber(text);\n    case 'N':\n      return parseNumber(text);\n    case 'O':\n      return parseNumber(text);\n    case 'D':\n      return parseDate(text);\n    case 'L':\n      return parseBoolean(text);\n    default:\n      throw new Error('Unsupported data type');\n  }\n}\n\n/**\n * Parse YYYYMMDD to date in milliseconds\n * @param {*} str\n */\nfunction parseDate(str) {\n  return Date.UTC(str.slice(0, 4), parseInt(str.slice(4, 6), 10) - 1, str.slice(6, 8));\n}\n\n/**\n * Read boolean value\n * any of Y, y, T, t coerce to true\n * any of N, n, F, f coerce to false\n * otherwise null\n * @param {*} value\n */\nfunction parseBoolean(value) {\n  return /^[nf]$/i.test(value) ? false : /^[yt]$/i.test(value) ? true : null;\n}\n\n/**\n * Return null instead of NaN\n * @param {*} text\n */\nfunction parseNumber(text) {\n  const number = parseFloat(text);\n  return isNaN(number) ? null : number;\n}\n\nfunction parseCharacter(text) {\n  return text.trim() || null;\n}\n"],"file":"parse-dbf-atomic.js"}