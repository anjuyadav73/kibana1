{"version":3,"sources":["../../../../../src/lib/parsers/deprecated/parse-shp-atomic.js"],"names":["LITTLE_ENDIAN","BIG_ENDIAN","SHP_MAGIC_NUMBER","SHP_HEADER_SIZE","SHP_RECORD_HEADER_SIZE","parseSHP","arrayBuffer","options","binaryReader","BinaryReader","headerView","getDataView","header","parseSHPHeader","currentIndex","geometries","hasAvailableBytes","recordHeaderView","recordHeader","recordNumber","getInt32","byteLength","type","invalidRecord","rewind","recordView","push","magic","length","version","bbox","minX","getFloat64","minY","minZ","minM","maxX","maxY","maxZ","maxM","console","error"],"mappings":"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","sourcesContent":["import BinaryReader from '../../streaming/binary-reader';\nimport {parseRecord} from '../parse-shp-geometry';\n\nconst LITTLE_ENDIAN = true;\nconst BIG_ENDIAN = false;\n\nconst SHP_MAGIC_NUMBER = 0x0000270a;\nconst SHP_HEADER_SIZE = 100;\n// According to the spec, the record header is just 8 bytes, but here we set it\n// to 12 so that we can also access the record's type\nconst SHP_RECORD_HEADER_SIZE = 8;\n\n/**\n * Atomically parse a shapefile from an ArrayBuffer\n * @param {ArrayBuffer} arrayBuffer\n */\nexport default function parseSHP(arrayBuffer, options) {\n  const binaryReader = new BinaryReader(arrayBuffer);\n\n  const headerView = binaryReader.getDataView(SHP_HEADER_SIZE);\n  const header = parseSHPHeader(headerView);\n\n  // index numbering starts at 1\n  let currentIndex = 1;\n  const geometries = [];\n\n  while (binaryReader.hasAvailableBytes(SHP_RECORD_HEADER_SIZE + 4)) {\n    const recordHeaderView = binaryReader.getDataView(SHP_RECORD_HEADER_SIZE + 4);\n    const recordHeader = {\n      recordNumber: recordHeaderView.getInt32(0, BIG_ENDIAN),\n      // 2 byte words; includes the four words of record header\n      byteLength: recordHeaderView.getInt32(4, BIG_ENDIAN) * 2,\n      // This is actually part of the record, not the header...\n      type: recordHeaderView.getInt32(8, LITTLE_ENDIAN)\n    };\n\n    const invalidRecord =\n      recordHeader.byteLength < 4 ||\n      recordHeader.type !== header.type ||\n      recordHeader.recordNumber !== currentIndex;\n\n    // All records must have at least four bytes (for the record shape type)\n    if (invalidRecord) {\n      // Malformed record, try again, advancing just 4 bytes\n      binaryReader.rewind(SHP_RECORD_HEADER_SIZE);\n    } else {\n      // Note: type is actually part of the record, not the header, so rewind 4 bytes befor reading record\n      binaryReader.rewind(4);\n\n      const recordView = binaryReader.getDataView(recordHeader.byteLength);\n      geometries.push(parseRecord(recordView, options));\n      currentIndex++;\n    }\n  }\n\n  return {\n    header,\n    geometries\n  };\n}\n\n/**\n * Extract the binary header\n * @param {DataView} headerView\n */\nexport function parseSHPHeader(headerView) {\n  // Note: The SHP format switches endianness between fields!\n  // https://www.esri.com/library/whitepapers/pdfs/shapefile.pdf\n  const header = {\n    magic: headerView.getInt32(0, BIG_ENDIAN),\n    // Length is stored as # of 2-byte words; multiply by 2 to get # of bytes\n    length: headerView.getInt32(24, BIG_ENDIAN) * 2,\n    version: headerView.getInt32(28, LITTLE_ENDIAN),\n    type: headerView.getInt32(32, LITTLE_ENDIAN),\n    bbox: {\n      minX: headerView.getFloat64(36, LITTLE_ENDIAN),\n      minY: headerView.getFloat64(44, LITTLE_ENDIAN),\n      minZ: headerView.getFloat64(68, LITTLE_ENDIAN),\n      minM: headerView.getFloat64(84, LITTLE_ENDIAN),\n      maxX: headerView.getFloat64(52, LITTLE_ENDIAN),\n      maxY: headerView.getFloat64(60, LITTLE_ENDIAN),\n      maxZ: headerView.getFloat64(76, LITTLE_ENDIAN),\n      maxM: headerView.getFloat64(92, LITTLE_ENDIAN)\n    }\n  };\n  if (header.magic !== SHP_MAGIC_NUMBER) {\n    // eslint-disable-next-line\n    console.error(`SHP file: bad magic number ${header.magic}`);\n  }\n  if (header.version !== 1000) {\n    // eslint-disable-next-line\n    console.error(`SHP file: bad version ${header.version}`);\n  }\n  return header;\n}\n"],"file":"parse-shp-atomic.js"}